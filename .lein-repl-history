"Whatever"
("Whatever")
(str "Whatever")
exit
(apply str "bob" "marley")
(apply clojure.string/upper-case "bob" "marley")
(apply clojure.string/upper-case "bob")
(apply (clojure.string/upper-case "bob"))
(apply (clojure.string/upper-case ""))
(apply clojure.string/upper-case "")
(apply clojure.string/upper-case "1")
(apply clojure.string/upper-case "22")
(apply clojure.string/upper-case "a")
(max [1 2 3])
(max 1 2 3)
(+ (map [1 2 3])
(+ (map [1 2 3]))
(+ 1 (map [1 2 3]))
(+ (map [1 2 3]))
(map [1 2 3])
(split "bob marley")
(clojure.string/split "bob marley")
(clojure.string/split "bobmarley")
(clojure.string/split "marley" "bob")
(clojure.string/join "," ["marley" "bob"])
(clojure.string/split ";" ["marley" "bob"])
(apply str "bob")
(seq "bob")
(clojure.string/upper-case (seq "bob"))
(if (clojure.string/upper-case (seq "bob")))
(clojure.string/upper-case (seq "bob"))
if (= true (clojure.string/upper-case (seq "bob"))
if (= true (clojure.string/upper-case (seq "bob")))
(if (= true (clojure.string/upper-case (seq "bob"))))
(if (clojure.string/upper-case? (seq "bob")))
(clojure.string/upper-case? (seq "bob"))
(= true (clojure.string/upper-case? (seq "bob")))
(clojure.string/upper-case? "BLA BLA BLA")
(clojure.string/split "Clojure is awesome" )
(clojure.string/split "Clojure is awesome" "More better than PHP")
(clojure.string/split "Clojure is awesome" "More better than PHP" #" ")
(clojure.string/split "Clojure is awesome" #" ")
(if clojure.string/upper-case? (map (clojure.string/split "Clojure is awesome" #" ")))
(if (Character/isUpperCase (map (clojure.string/split "Clojure is awesome" #" "))))
(if #(Character/isUpperCase (map (clojure.string/split "Clojure is awesome" #" "))))
(if (.isUpperCase (map (clojure.string/split "Clojure is awesome" #" "))))
(.isUpperCase "A")
(.toUpperCase "A")
(.toUpperCase "a")
(re-seq "abc" "abc")
(re-matches "abc" "abc")
#(Character.isUppercase "A")
(.Character.isUppercase "A")
(.isUppercase "A")
(clojure.string/isUppercase "A")
#(Character/isUppercase "A")
#(Character/isUppercase %)
(Character/isUppercase "A")
(filter (Character/isUppercase "A"))
(filter (Character/isUppercase %) "A")
(re-seq #"A-Z" "A")
(re-seq #"A-Z" "a")
(re-seq #"A-Z" "2")
(re-seq #"\d" "clojure 1.1.0")
(re-seq #"\s" "clojure 1.1.0")
(re-seq #"[A-Z]" "clojure 1.1.0")
(re-seq #"[A-Z]" "Clojure 1.1.0")
(re-seq #"[A-Z]" "FUCK you")
(not empty? (re-seq #"[A-Z]" "FUCK you")
(not empty? (re-seq #"[A-Z]" "FUCK you"))
(empty? (re-seq #"[A-Z]" "FUCK you"))
(empty? (re-seq #"[A-Z]" "you"))
exit
(defn is-upper-case? [phrase] 
  (empty? (re-seq #"[A-Z]" phrase)))
(is-upper-case? "AAAA")
(is-upper-case? "a")
(defn is-upper-case? [phrase] 
  (not (empty? (re-seq #"[A-Z]" phrase))))
(is-upper-case? "a")
(is-upper-case? "A")
exit
(defn is-upper-case? [phrase] 
  (not (every? (re-seq #"[A-Z]" phrase))))
(is-upper-case? "AaA")
(every? even? [2 4])
(every? even? [2 3])
(defn is-upper-case? [phrase] 
  (not (every? re-seq #"[A-Z]" phrase)))
(is-upper-case? "Aa")
(is-upper-case? ["A" "a"])
(re-seq #"[A-Z]" "AbC" )
(every? even? (re-seq #"[A-Z]" "AbC"))
(every? empty? (re-seq #"[A-Z]" "AbC"))
(every? nil? (re-seq #"[A-Z]" "AbC"))
(filter #(Character/isUpperCase %) `(\$ \# \A \( \* \& \9 \8 \7 \Z \f))
(filter #(Character/isUpperCase %) `(\$ \B)
(filter #(Character/isUpperCase %) `(\$ \B))
(filter #(Character/isUpperCase %) `(\$ \B \b))
(every? (Character/isUpperCase "Ola mundo"))
(every? Character/isUpperCase "Ola mundo")
(Character/isUpperCase \a)
(Character/isUpperCase \A)
(cons "Ola mundo")
(apply str "ola mundo")
(vec "ola mundo")
(every? (Character/isUpperCase (vec "ola mundo")
(every? (Character/isUpperCase (vec "ola mundo"))
(every? (Character/isUpperCase (vec "ola mundo")))
(every? (Character/isUpperCase '(vec "ola mundo")))
(every? (Character/isUpperCase \(vec "ola mundo")))
(every? (Character/isUpperCase ((vec "ola mundo"))))
(Character/isUpperCase every? ((vec "ola mundo"))))
(vec "ola mundo")
(vec "OLAMUNDO")
(every? char (vec "OLAMUNDO")
(every? char (vec "OLAMUNDO"))
(every? Character/isUpperCase (vec "OLAMUNDO"))
(every? #(Character/isUpperCase (vec "OLAMUNDO"))
(every? #(Character/isUpperCase (vec "OLAMUNDO")))
(every? Character/isUpperCase \a)
(every? #Character/isUpperCase \a)
(every? #(Character/isUpperCase \a))
(every? #(Character/isUpperCase} \a))
(every? #(Character/isUpperCase \a))
(every? '#(Character/isUpperCase \a))
(every? .isUpperCase \a))
(every? .isUp \a)
(every? .isUpperCase \a)
(every? (.isUpperCase \a))
(.isUpperCase \a))
(Chacaracter/isUpperCase \a))
(Character/isUpperCase \a))
(Character/isUpperCase \a)
(Character/isUpperCase \A)
(defn is-upper? [letter] (Character/isUpperCase letter))
(is-upper? \a)
(is-upper? \A)
(every? is-upper? \a)
(every? #(Character/isUpperCase %) "oioioi")
(every? #(Character/isUpperCase %) "oioioO")
(every? #(Character/isUpperCase %) "OI")
(Character/isUpperCase \a)
exit
(every #(Character/isUpperCase %) "OI!")
(every? #(Character/isUpperCase %) "OI!")
(every? #(Character/isUpperCase %) "OI")
(every? #(Character/isUpperCase %) "!")
(every? #(Character/isUpperCase %) (re-seq #"[a-zA-z]" "!")
(every? #(Character/isUpperCase %) (re-seq #"[a-zA-z]" "!"))
(every? #(Character/isUpperCase %) (re-seq #"[a-zA-z]" "Ab!"))
(every? #(Character/isUpperCase %) (re-seq #"[a-zA-z]" "!"))
(every? #(Character/isUpperCase %) (re-seq #"[a-zA-z]" "%"))
(every? #(Character/isUpperCase %) (re-seq #"[a-zA-z]" "8"))
(every? #(Character/isUpperCase %) (re-seq #"[a-zA-z]" "a"))
(every? #(Character/isUpperCase %) (re-seq #"[a-z]" "a"))
(every? #(Character/isUpperCase %) (re-seq #"\d" "a"))
(every? #(Character/isUpperCase %) (re-seq #"\d" "12"))
(every? #(Character/isUpperCase %) (re-seq #"\d" "a"))
(re-seq #"{a-z}" "ab")
(re-seq #"{a-z}" ["a" "b"])
(re-seq (#"{a-z}" ["a" "b"]))
(re-seq #"{a-z}" ["a" "b"])
(char "!")
(char? "!")
(char? "a")
(char? "A")
(char? "3312321fsfsfsfds")
(number? "3312321fsfsfsfds")
(number? "33")
(number? 33)
(char !)
(char "!")
(char? "!")
(char? "a")
(character? "a")
(char? \a)
(char? \!)
(filter #"{[a-z]}" \a)
(filter #"{[a-z]}" "a")
(filter #"[a-z]" "a")
(filter #"[a-z]" \a)
(filter #"[a-z]" "aaaaa")
(#"[a-z]" "aaaaa")
(filter even? [1 2 3]
(filter even? [1 2 3])
(filter str "dasdda!!")
(filter #"{a-zA-z}" "dasdda!!")
(filter (re-pattern "a-zA-z" "dasdda!!")
(filter (re-pattern "a-zA-z" "dasdda!!"))
(filter (re-find (re-pattern "a-zA-z" "dasdda!!")))
(filter (re-seq "a-zA-z" "dasdda!!"))
(re-seq "a-zA-z" "dasdda!!")
(re-seq #"{a-zA-z}" "dasdda!!")
(re-seq #"a-zA-z" "dasdda!!")
(re-seq #{"a-zA-z"} "dasdda!!")
(re-seq #"a-zA-z" "dasdda!!")
(re-seq #"\w" "dasdda!!")
(re-seq #"\w" "dasdda!!@@@@dadaola%%%&&****((")
(re-seq #"\w+" "dasdda!!@@@@dadaola%%%&&****((")
(every? #(Character/isUpperCase %) (re-seq #"\w+" "dasdda!!@@@@dadaola%%%&&****((")
(every? #(Character/isUpperCase %) (re-seq #"\w+" "dasdda!!@@@@dadaola%%%&&****"))
(every? #(Character/isUpperCase %) (apply (re-seq #"\w+" "dasdda!!@@@@dadaola%%%&&****")))
(apply (re-seq #"\w+" "dasdda!!@@@@dadaola%%%&&****"))
(apply str (re-seq #"\w+" "dasdda!!@@@@dadaola%%%&&****"))
(every? #(Character/isUpperCase %) (apply str (re-seq #"\w+" "dasdda!!@@@@dadaola%%%&&****"))
(every? #(Character/isUpperCase %) (apply str (re-seq #"\w+" "dasdda!!@@@@dadaola%%%&&****")))
(every? #(Character/isUpperCase %) (apply str (re-seq #"\w+" "dasdda!!@@@@dadaolA%%%&&****")))
(every? #(Character/isUpperCase %) (apply str (re-seq #"\w+" "Caralho!")))
(every? #(Character/isUpperCase %) (apply str (re-seq #"\w+" "CARALHO")))
(every? #(Character/isUpperCase %) (apply str (re-seq #"\w+" "Tom-ay-to, tom-aaaah-to.")))
(last (vec "dasdaadads"))
(last (vec "dasdaadads?"))
(= \? (last (vec "daddas?")))
(= \? (last (vec "daddas?a")))
(every? #(Character/isUpperCase %) (apply str (re-seq #"\w+" "ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!")))
#(Character/isUpperCase %) (apply str (re-seq #"\w+" "ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!")))
(Character/isUpperCase %) (apply str (re-seq #"\w+" "ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!")))
#(Character/isUpperCase %) (apply str (re-seq #"\w+" "ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!")))
(re-seq #"\w" "1312312dsaaasdsadas")
(re-seq #"\w" "100%$#&@@leo")
(re-seq #"\W" "100%$#&@@leo")
(re-seq #"\w\D" "100%$#&@@leo")
(re-seq #"\w\D" "%$#&@@leo")
(re-seq #"\w\D" "%$#&@@leo1132231123")
(re-seq #"\w\D" "ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!")
(re-seq #"\W\D" "ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!")
(re-seq #"\w\D" "ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!")
(re-seq #"[a-zA-Z]" "ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!")
(re-seq #"[a-zA-Z]+" "ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!")
(empty? "")
(empty? "               ")
(every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "1 2 3")
(every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "1 2 3")))
(re-seq #"[a-zA-Z]+" "1 2 3")
(apply str (re-seq #"[a-zA-Z]+" "1 2 3"))
(empty? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "1 2 3"))
(empty? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "1 2 3")))
(nil? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "1 2 3")))
(= nil? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "1 2 3")))
(= true #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "1 2 3")))
(= "" #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "1 2 3")))
#(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "1 2 3")))
(every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "1 2 3")))
(every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "")))
(every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "a")))
(every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "aA")))
(every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "")))
#(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" ""))
(not empty? (every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" ""))))
(not (empty? (every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "")))))
(defn is-upper-case? [characters] (every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" characters))))
(is-upper-case? "A")
(is-upper-case? "11")
(#(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "123 32321312")))
#(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "123 32321312"))
(defn is-upper-case? [characters] (every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" characters))))
(filter #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" characters)))
(filter even? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "2")))
(filter #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "2")))
(every? (filter #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "2"))))
(every? filter #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "2")))
(filter (every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "2"))))
(filter (every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "dasdasdadas"))))
(filter (every? #(Character/isUpperCase %) (apply str (re-seq #"[a-zA-Z]+" "dasdasdaAAAAAAAAAAAAdas"))))
(every? #(Character/isUpperCase %) (filter (apply str (re-seq #"[a-zA-Z]+" "dasdasdaAAAAAAAAAAAAdas"))))
(every? #(Character/isUpperCase %) (apply str (filter (re-seq #"[a-zA-Z]+" "dasdasdaAAAAAAAAAAAAdas"))))
(every? #(Character/isUpperCase %) (apply (filter (str (re-seq #"[a-zA-Z]+" "dasdasdaAAAAAAAAAAAAdas"))))
(every? #(Character/isUpperCase %) (apply (filter (str (re-seq #"[a-zA-Z]+" "dasdasdaAAAAAAAAAAAAdas")))))
(ends-with? s substr)
ends-with? s substr
ends-with? "s" "sas"
(clojure.string/ends-with? s substr)
(clojure.string/ends-with? "s" "substr")
(clojure.string/ends-with? "?" "substr?")
(clojure.string/ends-with? \? "substr?")
(clojure.string/ends-with? \? substr?)
(ends-with? "swapnil" "nil")
(clojure.string/ends-with? "swapnil" "nil")
(clojure.string/ends-with? "swapnil" "nil?")
(clojure.string/ends-with? "?" "nil?")
(clojure.string/ends-with? "nil?" "nil?")
(clojure.string/ends-with? "dasdadanil?" "nil?")
(clojure.string/ends-with? "?" "?")
(clojure.string/ends-with? "dsasadsadsasd?" "?")
(clojure.string/ends-with? "dsasadsadsdsadsadsadasasd?" "?")
(clojure.string/ends-with? "dsasadsadsdsadsadsadasasd?" "d?")
(clojure.string/ends-with? "dsasadsadsdsadsadsadasasd?" \?)
(clojure.string/blank? "               ")
